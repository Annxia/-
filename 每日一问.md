##  背一背
1. 一台客户端有300个客户，和300个客户端有300个客户对服务器施压，有什么区别？
    300个客户在同一客户端上，会占用客户机更多的资源，而影响测试的结果。线程之间可能发生干扰，而产生一些异常。
    300个用户在一个客户端上，需要更大的带宽。
    IP地址的问题，可能需要使用IP Spoof来绕过服务器对于单一IP地址最大连接数的限制。
    所有用户在一个客户端上，不必考虑分布式管理的问题。
    而用户分布在不同的客户端上，需要考虑使用控制器来整体调配不同客户机上的用户。同时，还需要给予相应的权限配置和防火墙设置。

2. 目前主要的测试用例设计方法是什么？
    白盒测试：逻辑覆盖、循环覆盖、基本路径覆盖
    黑盒测试：边界值分析法、等价类划分、错误猜测法、因果图法、状态图法、测试大纲法、随机测试、场景法

3. cookie和session是什么意思？有什么区别
    Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID，用该SessionID为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。

    服务器也可以通过URL重写的方式来传递SessionID的值，因此不是完全依赖Cookie。如果客户端Cookie禁用，则服务器可以自动通过重写URL的方式来保存Session的值，并且这个过程对程序员透明。

    可以试一下，即使不写Cookie，在使用request.getCookies();取出来的Cookie数组的长度也是1，而这个Cookie的名字就是JSESSIONID，还有一个很长的二进制的字符串，是SessionID的值

    Cookie是客户端的存储空间，由浏览器来维持。
    （cookie是一个具体存在的东西，因为http的无状态特点，cookie是帮助http辨别用户身份保持一些状态的工具，但是cookie是明文存放在本地，很容易被篡改，所以就想到把这个想要保留的状态放在服务端，所以session其实是借助cookie的一种服务端的实现，只给用户本地存一个id，id就是cookie存的内容，用户只要带着这个id发给服务器，服务器端就能判断你的状态）

4. lambda函数
    1. 匿名函数，使用python写一些执行脚本时，使用lambda函数可以省去定义函数的过程，使得代码更加精简
    2. 对于一些抽象的，不会在别的地方再复用的函数，有时候给函数起名字也是个难题，使用lambda就不需要考虑命名的问题
    3. 使用lambda在某些时候让代码更容易理解

5. map函数
    map是python内置函数，会根据提供的函数对指定的序列做映射
    ` map(function,iterable,...) `
    map 不改变原list，而是返回一个新的list
    ` map(lambda x,y: x+y,[1,3,5,7,9],[2,4,6,8,10])  
     #结果如下
     [3,7,11,15,19]
    `
    
6. rpc,http的区别

7. java依赖注入  
    构造方法注入，setter注入、基于注解的注入

8. linkedlist和arraylist

9. 垃圾回收机制  
    在Java中，程序员不需要去关心内存动态分配和垃圾回收的问题，这一切都交给了JVM来处理。
    - 标记垃圾的算法
        - 引用计数法:给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的，可以当做垃圾收集  
            - 优点:执行效率高，程序执行受影响较小
            - 缺点:无法检测出循环引用的情况，导致内存泄漏  
        - 可达性分析算法:这个算法的基本思想就是通过一系列的称为"GC Roots"的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到"GC Roots"没有任何引用链相连的话，则证明此对象是不可用的。
            1. 那么什么对象可以作为GCRoot:
            - 虚拟机栈中的引用对象
            - 方法区中的常量引用对象
            - 方法区中的类静态属性引用对象
            - 本地方法栈中的引用对象
            - 活跃线程中的引用对象
            2. 那么不可达的对象是否是必死之局？答案也是否定的  
            在可达性分析法中不可达的对象，他们暂时处于"缓刑阶段",要真正宣告一个对象死亡,至少要经历两次标记过程;可达性分析法中不可达的对象被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行finalize方法。当对象没有覆盖finalize方法,或finalize方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。  


10. linux文件权限
   - ls l 文件名:查看文件权限  
    **注意点:**查看文件权限目录的问题：如果有文件夹 /a/b/c  
    ls l /a 查看的是b文件的权限  
    ls l /a/b 查看的是c文件的权限  
    ls l /a/b/c 查看的是c文件的权限  
   - chmod:改变文件权限    
    chmod 权限数字 文件名  
    r:读权限read,4  
    w:写权限，2  
    x:操作权限execute,1  
    权限数字对应权限组说明：总共分为4部分：  
    【文件或文件夹】【owner权限】【group权限】【others权限】  
    【文件是-，文件夹是d】【r/w/x相加】【r/w/x相加】【r/w/x相加】  

   - chown:改变文件属主  

11. linux环境变量   
    - `export`命令显示当前系统定义的所有环境  
    - `echo $PATH`命令输出当前的PATH环境变量的值    
    如想将一个路径加入到$PATH中：  
    1. 只对当前shell起作用的环境变量   
    直接控制台中输入：$PATH="$PATH:/NEW_PATH"(关闭shell后Path还是原来的Path)
    2. 对所有的用户都起作用的环境变量   
    vi /etc/profile
    在/etc/profile的最下面添加：export  PATH = "$PATH:/NEW_PATH"  
    3. 针对当前特定的用户起作用的环境变量：修改bashrc文件   
    vi ~/.bashrc  
    在下面填写： Export PATH="$PATH:/NEW_PATH"  


12. mysql联表查询  


13. TCP长连接和短连接的区别

14. python装饰器

15. 多线程和多进程的区别
    **进程是资源分配的最小单位，线程是CPU调度的最小单位**  
    - 进程的本质:正在执行的一个程序们可以比喻成一个容器或工厂。一个程序一旦在计算机里运行起来，它就成为一个进程，进程与进程之间可以通信、同步、竞争，并在一定情况下可能形成死锁。
        - 进程与进程之间相对独立
        - 进程可以包括几个或者上百个线程在运行
        - 内存(逻辑内存)包括在进程里面，每个进程的内存都是互相独立的，但从一个更高的层次上看，不同的进程也共享着一个巨大的空间，这个空间就是整个计算机。
        - 进程共有文件/网络句柄(handle),这样可以打开同一个文件，抢同一个网络端口。
    - 线程的本质:真正运行的是一个一个的线程，进程在一个时间只能干一个事情，如果相同时干两件事情就要用到线程。线程是进程里面的一个执行上下文或者执行序列。线程包括：  
        - 栈(堆栈):主线程的main函数、进行函数调用的参数和返回地址、局部变量等内容都会被压入栈内。
        - PC(Program counter):程序计数器，PC的指针指向代码所在的内存地址。
        - TLS(Thread local storage):分配内存，存放变量  
    - 如何通信？  
        - 进程可以通过管道、套接字、信号交互、共享内存、消息队列等进行通信
        - 线程本身就会共享内存，指针指向同一个内容，交互很容易  
    - 如何同步(协调)？
        - 在单个CPU下，实际上在任何时刻只能有一个进程处于执行状态。而其他进程则处于非执行状态。我们是如何确定在任意时刻到底由哪个进程执行，哪些不执行？进而又可以引出锁的概念
        - 线程之间是合作关系。既然是合作，那就得有某种约定的规则，否则合作就会出问题。(如何进行线程同步)


16. HTTP状态码
    - 1xx:通知
        - 100("Continue")  重要程度：中等，但(写操作)很少用
        - 101  重要程度:非常低
    - 2xx:成功
        - 200("ok") 一切正常。
    - 3xx:重定向
        - 301:当客户端触发的动作引起了资源URI的变化时发送此响应代码。另外，当客户端向一个资源的旧URI发送请求时，也发送此响应代码。
    - 4xx:客户端错误
        - 404("Not Found") 服务器不知道客户端要请求那个资源
        - 410("Gone") 服务器端知道客户端所请求的资源曾经存在，但现在已经不存在了
        - 409("Confilct") 当客户端试图执行一个会导致一个或多个资源处于不一致状态的操作时，发送此代码
    - 5xx:服务端错误
        - 500("Internal Server Error") 通用的服务器错误响应，对于大多数web框架，如果在执行请求处理代码时遇到一场，它们就发送此代码
        - 501("Not Implemented") 客户端试图使用一个服务器不支持的HTTP特性
        - 502("Bad Gateway") 只有HTTP代理会发送这个响应代码。它表明代理方面出现问题，或者代理与上行服务器之间出现问题，而不是上行服务器本身出现问题。

17. 重写和重载
    - 方法重写  
    在Java程序中，类的继承关系可以产生一个子类，子类继承父类，它具备了父类所有的特征，继承了父类所有的方法和变量。  
    子类可以定义新的特征，当子类需要修改父类的一些方法进行扩展，增大功能，程序设计者常常把这样的一种操作方法称为重写。  
    重写是建立在继承关系上的，方法的重写指子类中的方法与父类中继承的方法有完全相同的返回值类型、方法名、参数个数以及参数类型。  
    可以使用`super`关键字从子类访问父类中的方法。  
    父类中的方法并不是在任何情况下都能被重写的，当父类中的方法的访问权限修饰符为private时，该方法只能被自己的类访问，不能被外部的类访问，在子类中是不能被重写的。  
    在继承过程中如果父类当中的方法抛出异常，那么子类中重写父类的该方法时，也要抛出异常，而且抛出的异常不能多于父类中抛出的异常。换句话说，重写方法一定不能抛出新的检查异常，或者比被重写方法声明更加宽泛的检查异常。例如，父类的方法声明了一个IOException，在重写这个方法时就不能抛出Exception，只能抛出IOException的子类异常。  
    - 方法重载  
    方法重载是让类以统一的方式处理不同类型数据的一种手段。调用方法时通过传递给它们的不同个数和类型的参数来决定具体使用哪个方法，这就是多态性。  
    所谓方法重载指的是在一个类中，多个方法的方法名相同，但是参数列表不同。参数列表不同指的是参数个数、参数类型或者参数的顺序不同。  
    - 区别  
    方法重载：  
    1. 同一个类中
    2. 方法名相同，参数列表不同(参数顺序、个数、类型)
    3. 方法返回值、访问修饰符任意  
    4. 与方法的参数名无关  
    方法重写：
    1. 有继承关系的子类中
    2. 方法名相同，参数列表相同(参数顺序、个数、类型)，方法返回值相同  
    3. 访问修饰符，访问范围需要大于等于父类的访问范围
    4. 与方法的参数名无关  


18. TCP、UDP区别  
    ![]()
     


19. TCP三次握手

20. shell 杀某一应用的对应进程

21. python深拷贝浅拷贝

22. linux命令cat,less,more,vi区别  
    `vi`是编辑器，如果文件很大好几十G,那么vi一下，则会把所有文件都加载到内存中，导致服务器瘫痪。因此查看文件不能用vi,比较好用的有`less`,`cat`,`tail`  
    - `less 文件名`:在查看之前不会加载整个文件
        - 回车键:向下移动一行
        - y:向上移动一行
        - 空格键:向下滚动一屏
        - b:向上滚动一屏
        - d:向下滚动半屏
        - u:向上滚动半屏
        - g:跳到第一行
        - G:跳到最后一行
        - /pattern:搜索pattern，比如/mail表示在文件中搜索mail单词
        - q:退出less
        - !command:调用Shell，可以运行命令，比如:!ls显示当前列当前目录下的所有文件
        - shift + f:启动流式模式，类似于tail -f功能
    - `cat 文件名`:一次性显示整个文件的内容，还可以将多个文件连接起来显示，它常与重定向符号配合使用，适用于文件内容少的情况  
        - cat 文件1 文件2 文件3 > 文件名:将几个文件合并为一个文件
        - cat -n filename: 显示整个文件，加上行号
        - cat > filename:只能创建新文件，不能编辑已有文件
    - `more`:功能类似于`cat`,逐页显示文件内容，启动时就会加载整个文件
        - 空白键:往下一页显示
        - b:往回一页显示
        - Enter:向下n行，需要定义，默认1行
        - Ctrl+B:返回上一屏
        - =:输出当前行的行号
        - :f:输出文件名和当前行的行号
        - q:退出more

23. rm如何避免做到误删

24. 四层网络协议基本概念，HTTP请求属于哪一层协议

25. 关系数据库主键、索引的概念

26. inner join 和left join的概念  
    `inner join`:搜索出a,b两表都有的数据。    
    `left join`:左表数据全部+右表符合`on`条件的数据。左右表互换结果就不一样。    

27. python装饰器    

28. Linux动态查看资源占用情况的命令  

29. 软件测试的流程
    1. 需求评审
    2. 测试计划
    3. 测试策略和要点(思维导图梳理测试策略和测试要点)
    4. 测试用例
    5. 用例评审
    6. 测试实施
    7. 提交缺陷
    8. 回归测试
    9. 根据项目实际情况与产品经理项目经理坍台是否再次深入修复缺陷
    10. 测试报告和总结

30. linux 打包一个tar.gz文件的命令
    - `tar`命令主要是将众多文件打包成一个文件并压缩  

    参数| 参数描述  
    ---|---
    -C|创建新的档案文件
    -c|指定到要解压到问目录，注意：该目录必须存在
    -f|指定打包的文件名。在f后要立即接打包文件名，不要再加参数
    -x|解压
    -O|将文件解压到标准输出
    -P|使用原文件的原来属性
    -p|创建归档文件，使用绝对路径
    -t|列出档案文件中的内容
    -r|向压缩归档文件末尾追加文件
    -u|更新原压缩包中的文件
    -v|显示详细过程
    -z|使用gzip压缩，一般格式为xx.tar.gz或xx.tgz
    -Z|有compress
    -j|使用bzip2压缩，一般格式为xx.tar.bz2
    --ecxlude|在压缩过程中排除某个文件
    --remove-files|在完成打包后，删除原文件夹

    **注意事项**:  
    1. 在上述参数中，c/x/t仅能存在一个，不可同时存在
    2. -f:指定打包的文件名，切记，这个参数是最后一个参数，最后只能接打包文件名
    3. 参数可以合并在一起，也可以单独分开  

    **filename:打包后的文件名**    
    **dirname:需要打包的文件名**
    - `.tar`格式  
    解包: `tar -xvf filename`
    打包:`tar -cvf filename.tar dirname`  
    - `.gz`格式  
    打包:`tar -zcvf filename.tar.gz dirname`  **使用gzip压缩
    解包1:`tar -xjvf filename.tar.bz2`
    解包2:`tar -xzvf filename.tar.gz`
    - 查看打包了哪些文件  
    `tar -tf filename.tar.gz`  不加参数z或j也是能查看的
    - 打包压缩后删除原文件夹或原文件
    `tar -zcvf filename.tar.gz dirname --remove-files`  


31. linux在只知道文件部分内容的情况下怎么去查找文件名和文件所在路径
    `grep -nri keyword your_dir`
    - grep:搜索指定文件的内容，匹配指定的模式，默认情况下输出匹配内容所在的行  
    **grep [options] pattern [file...]**  
    **grep [options] [-e pattern | -f file][file]**

    参数|参数描述
    ---|---
    -V|--version
    -G|--basic-regexp,BRE模式，也是默认的模式
    -E|ERE模式
    -P|PRE模式
    -F|--find-strings,指定的模式被解释为字符串
    -i|忽略大小写
    -o|只输出匹配到的部分，而不是整个行
    -v|反向选择，即输出没有匹配的行
    -c|计算找到的符号行的次数
    -n|顺便输出行号 
    -w|匹配全词



32. linux怎么拷贝文件到服务器上

33. sql语句的复合查询

34. sql的函数用过哪些



